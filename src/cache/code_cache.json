{"cached_url": "https://github.com/alexwohlbruck/cat-facts/tree/master/app", "cached_index": {"app/models/api-log.js": "const mongoose = require('mongoose');\nconst Schema = mongoose.Schema;\nconst mongooseDelete = require('mongoose-delete');\nconst random = require('mongoose-simple-random');\nconst { animalTypes } = require('../config/strings.js');\n\nconst ApiLogSchema = new Schema({\n\thost: String,\n\tbody: String,\n\tclientIp: String,\n\toriginalUrl: String\n}, {\n\ttimestamps: true\n});\n\nconst ApiLog = mongoose.model('ApiLog', ApiLogSchema);\n\nmodule.exports = ApiLog;", "app/models/fact.js": "const mongoose = require('mongoose');\nconst Schema = mongoose.Schema;\nconst mongooseDelete = require('mongoose-delete');\nconst random = require('mongoose-simple-random');\nconst { animalTypes } = require('../config/strings.js');\n\nconst FactSchema = new Schema({\n    user: { type: Schema.Types.ObjectId, ref: 'User' },\n    text: { type: String, required: true, unique: true },\n    sendDate: { type: Date },\n    type: { type: String, enum: animalTypes, default: 'cat' },\n    status: {\n        verified: { type: Boolean, default: null },\n        feedback: { type: String },\n        sentCount: { type: Number, default: 0 }\n    }\n}, {\n    timestamps: true\n});\n\n/**\n * Soft delete implementation\n * https://github.com/dsanel/mongoose-delete\n */\nFactSchema.plugin(mongooseDelete, { overrideMethods: true });\nFactSchema.plugin(random);\n\nFactSchema.statics.getFact = function({ amount = 1, filter = {}, animalType = 'cat' }) {\n\n    if (typeof animalType === 'string') {\n        animalType = [animalType];\n    }\n\n    const query = {\n        ...filter,\n        type: { $in: animalType }\n    };\n\n    return new Promise((resolve, reject) => {\n        this.findRandom(query, {}, { limit: amount }, (err, facts) => {\n            if (err) return reject(err);\n            facts = facts || [];\n\n            resolve(amount == 1 ? facts[0] : facts);\n        });\n    });\n};\n\nconst Fact = mongoose.model('Fact', FactSchema);\n\nmodule.exports = Fact;", "app/models/message.js": "var mongoose = require('mongoose');\nvar Schema = mongoose.Schema;\n\nvar MessageSchema = new Schema({\n    text: {type: String, required: true},\n    number: {type: String, required: true},\n    type: {type: String, enum: ['incoming', 'outgoing']}\n}, {\n    timestamps: true\n});\n\nMessageSchema.index({ \"createdAt\": 1 }, { expireAfterSeconds: (60 * 60 * 24 * 7 * 2) });\n\nvar Message = mongoose.model('Message', MessageSchema);\n\nmodule.exports = Message;", "app/models/recipient.js": "const mongoose = require('mongoose');\nconst Schema = mongoose.Schema;\nconst strings = require.main.require('./app/config/strings');\nconst mongooseDelete = require('mongoose-delete');\n\nconst IFTTTService = require('../services/ifttt.service.js');\nconst { semanticJoin } = require('../config/functions');\nconst { validatePhoneNumber, cleanPhoneNumber } = require('../config/functions');\n\nconst RecipientSchema = new Schema({\n    name: { type: String, default: undefined },\n    notes: { type: String, default: undefined, select: false },\n    number: {\n        type: String,\n        required: true,\n        unique: true,\n        validate: [validatePhoneNumber]\n    },\n    addedBy: {type: Schema.Types.ObjectId, ref: 'User'},\n    subscriptions: [{\n        type: String,\n        enum: strings.animalTypes // TODO: Move to constant definition\n    }]\n}, {\n    timestamps: true\n});\n        \n\nRecipientSchema.statics.addRecipients = async function ({authenticatedUser, requestedRecipients, requestedSubscriptions}) {\n    \n    // TODO: Create user account for people who add recipients over SMS, attach phone number to user account and\n    // attach user ID to recipient document as 'addedBy'\n        \n    let existingRecipients = await this.find({number: {$in: requestedRecipients.map(r => r.number)}}),\n        newRequestedRecipients = requestedRecipients.filter(requestedRecipient => {\n            return !existingRecipients.find(existingRecipient => {\n                return requestedRecipient.number == existingRecipient.number;\n            });\n        });\n    \n    const addNewRecipients = async recipients => {\n        // This is a new recipient\n        \n        recipients = recipients.map(recipient => {\n            return {\n                name: recipient.name,\n                number: cleanPhoneNumber(recipient.number),\n                addedBy: authenticatedUser ? authenticatedUser._id : undefined,\n                subscriptions: requestedSubscriptions\n            };\n        });\n        \n        return await Recipient.create(recipients);\n    },\n    addSubscriptionsToExistingRecipients = async recipients => {\n    \n        const existingRecipientPromises = recipients.map(recipient => {\n            return Recipient.findByIdAndUpdate(recipient._id, {\n                $addToSet: {\n                    subscriptions: {\n                        $each: requestedSubscriptions\n                    }\n                }\n            }, {\n                'new': true\n            });\n        });\n    \n        return await Promise.all(existingRecipientPromises);\n    },\n    \n    buildMessagesForNewRecipients = ({recipients}) => {\n        return {\n            responseMessage: `Okay, I've added ${semanticJoin(recipients.map(r => r.name))} to ${semanticJoin(requestedSubscriptions)} facts!`,\n            smsMessage: strings.welcomeMessage(requestedSubscriptions)\n        };\n    },\n    buildMessagesForExistingRecipients = ({recipients}) => {\n          \n        let responseMessage = '',\n            smsMessage = '',\n            abortSms = false;\n    \n        if (recipients.length > 1) {\n            responseMessage += `Okay, I've added ${semanticJoin(recipients.map(r => r.name))} to ${semanticJoin(requestedSubscriptions)} facts!`;\n              smsMessage += strings.welcomeMessage(requestedSubscriptions);\n        } else {\n         \n            const recipient = recipients[0];\n              \n            // Figure out which new animals to subscribe user to\n            const existingSubscriptions = recipient.subscriptions;\n            const subscriptionsToAdd = requestedSubscriptions.filter(a => !existingSubscriptions.includes(a));\n            const subscriptionsToIgnore = requestedSubscriptions.filter(a => existingSubscriptions.includes(a));\n              \n            // Build response message\n            const alreadySubscribedMessage = `${recipient.name} is already subscribed to ${semanticJoin(subscriptionsToIgnore)} facts`;\n              \n            const alreadySubscribed = !!subscriptionsToIgnore.length,\n                  moreToAdd = !!subscriptionsToAdd.length;\n              \n            if (alreadySubscribed) {\n                responseMessage += alreadySubscribedMessage;\n            }\n            if (alreadySubscribed && moreToAdd) {\n                responseMessage += `, but `;\n            }\n            if (moreToAdd) {\n                responseMessage += `I've added ${alreadySubscribed ? 'them' : recipient.name} to ${semanticJoin(subscriptionsToAdd)} facts`;\n            } else {\n                abortSms = true;\n            }\n            responseMessage += '.';\n              \n            // Build SMS message\n            smsMessage += `Surprise! You've also been added to ${semanticJoin(subscriptionsToAdd)} facts. Have a nice day!`;\n        }\n          \n        return {\n            responseMessage,\n            smsMessage: abortSms ? undefined : smsMessage,\n            abortSms\n        };\n    },\n    \n    sendMessages = ({recipients, message}) => {\n        // TODO: also send message app using websocket\n        // io.emit('message', {message, recipient});\n          \n        // Send SMS to recipient\n        IFTTTService.sendBatchMessages(recipients.map(recipient => {\n            return {\n                number: recipient.number,\n                message\n            };\n        }));\n    };\n\n    try {\n        var newRecipients = await addNewRecipients(newRequestedRecipients);\n        var updatedRecipients = await addSubscriptionsToExistingRecipients(existingRecipients);\n    }\n    catch (err) {\n        throw err;\n    }\n    \n    // TODO: DRY these\n    if (newRecipients && newRecipients.length) {\n        var { smsMessage: newSmsMessage, responseMessage: newResponseMessage, abortSms } = buildMessagesForNewRecipients({recipients: newRequestedRecipients});\n        if (!abortSms) sendMessages({recipients: newRecipients, message: newSmsMessage});\n    }\n    \n    if (updatedRecipients && updatedRecipients.length) {\n        var { smsMessage: updatedSmsMessage, responseMessage: updatedResponseMessage, abortSms } = buildMessagesForExistingRecipients({recipients: existingRecipients});\n        if (!abortSms) sendMessages({ recipients: updatedRecipients, message: updatedSmsMessage });\n    }\n    \n    return {\n        newRecipients: newRecipients || [],\n        updatedRecipients: updatedRecipients || [],\n        // TODO: Merge these messages into one\n        message: newResponseMessage || updatedResponseMessage\n    };\n};\n\nRecipientSchema.path('number').validate(function(number, done) {\n    this.model('Recipient').count({number: number}, function(err, count) {\n        if (err) return err;\n        return !count;\n    });\n}, strings.recipient.exists);\n\n/**\n * Soft delete implementation\n * https://github.com/dsanel/mongoose-delete\n */\nRecipientSchema.plugin(mongooseDelete, {overrideMethods: true});\n\nconst Recipient = mongoose.model('Recipient', RecipientSchema);\n\nmodule.exports = Recipient;", "app/models/unsubscribe-date.js": "const mongoose = require('mongoose');\nconst Schema = mongoose.Schema;\nconst Promise = require('bluebird');\n\nconst UnsubscribeDateSchema = new Schema({\n    start: {type: Date, required: true},\n    end: {type: Date, required: true}\n}, {\n    timestamps: true\n});\n\nconst isBetweenDates = function(target, min, max) {\n    return (min < target) && (target < max);\n};\n\nUnsubscribeDateSchema.statics.allowUnsubscribe = function() {\n    return new Promise((resolve, reject) => {\n        this.model('UnsubscribeDate').find().then(unsubscribableDates => {\n            const now = new Date();\n            \n            const canUnsubscribe = unsubscribableDates\n                .map(range => {\n                    return isBetweenDates(now, range.start, range.end);\n                })\n                .reduce((sum, value) => sum || value);\n                \n            resolve(canUnsubscribe);\n        }, err => {\n            reject(err);\n        });\n    });\n};\n\nconst UnsubscribeDate = mongoose.model('UnsubscribeDate', UnsubscribeDateSchema);\n\nmodule.exports = UnsubscribeDate;", "app/models/user.js": "const mongoose = require('mongoose');\nconst Schema = mongoose.Schema;\nconst crypto = require('crypto');\nconst mongooseDelete = require('mongoose-delete');\n\nconst keys = require.main.require('./app/config/keys');\nconst strings = require.main.require('./app/config/strings');\n\n// Make email and phone docs unique except for those that are flagged as deleted\nconst uniquePartialIndex = {\n    unique: true,\n    partialFilterExpression: {\n        deleted: false\n    }\n};\n\nconst UserSchema = new Schema({\n    name: {\n        first:  {type: String, required: true},\n        last:   {type: String, required: true}\n    },\n    email:      {type: String},\n    phone:      {type: String},\n    photo:      {type: String, default: strings.userPhotoUrl},\n    google: {\n        id:           {type: String},\n        accessToken:  {type: String},\n        refreshToken: {type: String}\n    },\n    isAdmin: {type: Boolean, default: false},\n    ip: String\n}, {\n    timestamps: true\n});\n\nUserSchema.statics.encryptAccessToken = function(plainText) {\n    return crypto\n        .createCipher(keys.encryption.algorithm, keys.encryption.key)\n        .update(plainText, 'utf-8', 'hex');\n};\n\nUserSchema.statics.decryptAccessToken = function(cipher) {\n    return crypto\n        .createDecipher(keys.encryption.algorithm, keys.encryption.key)\n        .update(cipher, 'hex', 'utf-8');\n};\n\nUserSchema.plugin(mongooseDelete, {overrideMethods: true});\n\nUserSchema.index({email: 1, phone: 1}, uniquePartialIndex);\n\nvar User = mongoose.model('User', UserSchema);\n\nmodule.exports = User;", "app/models/verification-code.js": "const mongoose = require('mongoose');\nconst Schema = mongoose.Schema;\nconst shortid = require('shortid');\n\nconst VerificationCodeSchema = new Schema({\n    code: {type: String, required: true, unique: true, default: shortid.generate},\n    user: {type: Schema.Types.ObjectId, ref: 'User', required: true},\n    type: {type: String, enum: ['phone'], default: 'phone'},\n    data: {type: String, required: true}\n}, {\n    timestamps: true\n});\n\nVerificationCodeSchema.index({ \"createdAt\": 1 }, { expireAfterSeconds: (60 * 60 * 1) });\n\nconst VerificationCode = mongoose.model('VerificationCode', VerificationCodeSchema);\n\nmodule.exports = VerificationCode;", "app/routes/auth.routes.js": "const express = require('express');\nconst router = express.Router();\nconst passport = require('passport');\nconst googleConfig = require('../config/google');\nconst { isAuthenticated } = require('../middleware');\n\nconst User = require.main.require('./app/models/user');\n\nconst baseScopes = [\n\t'email',\n\t'profile'\n],\ncontactsScopes = [\n\t'https://www.googleapis.com/auth/contacts.readonly'\n];\n\nrouter.get('/google', passport.authenticate('google', {\n\tscope: baseScopes,\n\taccessType: 'offline',\n\tincludeGrantedScopes: true\n}));\n\nrouter.get('/google/callback', passport.authenticate('google', {\n\tfailureRedirect: '/login'\n}), function(req, res) {\n\tres.redirect('/#/cat/facts');\n});\n\nrouter.get('/google/contacts', isAuthenticated, (req, res) => {\n\t\n\tvar oauth2Client = googleConfig.newOauth2Client({\n\t\taccessToken: User.decryptAccessToken(req.user.google.accessToken),\n\t\trefreshToken: req.user.google.refreshToken\n\t});\n\t\n\tvar url = oauth2Client.generateAuthUrl({\n\t\taccessType: 'offline',\n\t\tscope: contactsScopes,\n\t\tstate: encodeURIComponent(JSON.stringify({\n\t\t\taction: 'contacts:import'\n\t\t})),\n\t\tincludeGrantedScopes: true\n\t});\n\t\n\treturn res.redirect(url);\n});\n\nrouter.get('/google/contacts/callback', (req, res, next) => {\n\tvar oauth2Client = googleConfig.newOauth2Client();\n\t\n\toauth2Client.getToken(req.query.code, (err, tokens) => {\n\t\tif (err) return res.status(400).json(err);\n\t\t\n\t\tUser.findByIdAndUpdate(req.user._id, {\n\t\t\t'google.accessToken': User.encryptAccessToken(tokens.access_token),\n\t\t\t'google.refreshToken': tokens.refresh_token\n\t\t}).then(user => {\n\t\t\t// Re-serialize user after updating data\n\t\t\treq.login(user, err => {\n\t\t\t\tif (err) return next(err);\n\t\t\t\t\n\t\t\t\tuser.google.accessToken = User.decryptAccessToken(user.google.accessToken);\n\t\t\t\t\n\t\t\t\treturn res.status(req.user ? 200 : 204).render('../public/views/other/after-auth', {\n\t\t\t\t\tstate: JSON.parse(decodeURIComponent(req.query.state))\n\t\t\t\t});\n\t\t\t});\n\t\t}, err => {\n\t\t\tconsole.log(err);\n\t\t});\n\t});\n});\n\nrouter.get('/signout', (req, res) => {\n\treq.logout();\n\tres.status(200).send();\n});\n\nmodule.exports = router;", "app/routes/catbot.routes.js": "const express = require('express');\nconst router = express.Router();\nconst Promise = require('bluebird');\n\nconst apiai = require('apiai-promise');\nconst keys = require('../config/keys');\nconst catbot = apiai(keys.apiai.accessToken);\nconst strings = require('../config/strings.js');\nconst twitter = require('../services/twitter.service');\n\nconst Fact = require('../models/fact');\nconst Message = require('../models/message');\nconst Recipient = require('../models/recipient');\n\n\nconst todayStart = new Date();\ntodayStart.setHours(0, 0, 0, 0);\nconst todayEnd = new Date();\ntodayEnd.setHours(23, 59, 59, 999);\n\n\n// Get all recipients and a fact to be sent out each day\nrouter.get('/daily', async(req, res) => {\n\n    if (!req.query || req.query.code !== keys.generalAccessToken) {\n        return res.status(400).json({ message: \"Provide the code to recieve recipients\" });\n    }\n\n    const io = req.app.get('socketio');\n\n    const todayStart = new Date();\n    todayStart.setHours(0, 0, 0, 0);\n    const todayEnd = new Date();\n    todayEnd.setHours(23, 59, 59, 999);\n\n    let getFactAndRecipients = async animalType => {\n        let { recipients, overrideFact, fact } = await Promise.props({\n\n            recipients: Recipient.find({\n                subscriptions: animalType\n            }, {\n                number: 1\n            }),\n\n            overrideFact: Fact.findOne({\n                sendDate: {\n                    $gte: todayStart,\n                    $lte: todayEnd\n                },\n                type: animalType\n            }),\n\n            fact: Fact.getFact({ animalType })\n        });\n\n        if (!fact) {\n            // TODO: New behavior if there are no avaialable facts\n            // ? Send error message?\n            // No unused facts are available, reset all facts to unused\n            // await Fact.update({}, {$set: {used: false}}, {multi: true});\n        }\n\n        if (overrideFact) {\n            await overrideFact.delete();\n        }\n\n        return {\n            recipients: recipients.map(r => r.number),\n            fact: (overrideFact || fact).text\n        };\n    };\n\n    const facts = {};\n    strings.animalTypes.forEach(animal => {\n        facts[animal] = getFactAndRecipients(animal);\n    });\n\n    const result = await Promise.props(facts),\n        dbMessages = [];\n\n    Object.keys(result).forEach(async animal => {\n\n        // Increment sent count\n        await Fact.findByIdAndUpdate(result[animal].fact._id, {\n            $inc: {\n                'status.sentCount': 1\n            }\n        });\n\n        result[animal].recipients.forEach(async recipient => {\n\n            // Send messages to app\n            io.emit('message', {\n                message: result[animal].fact.text,\n                recipient: recipient\n            });\n\n            dbMessages.push(new Message({\n                text: result[animal].fact.text,\n                number: recipient.number,\n                type: 'outgoing'\n            }));\n        });\n\n        // Format data for response\n        result[animal] = {\n            recipients: result[animal].recipients.map(r => r.number),\n            fact: result[animal].fact.text,\n        };\n    });\n\n    // Save messages to database\n    await Message.create(dbMessages);\n\n    // Tweet only the cat fact\n    twitter.tweet(result.cat.fact);\n\n    return res.status(200).json(result);\n});\n\n// Text was recieved from recipient, process it and respond\nrouter.post('/message', (req, res) => {\n\n    if (!req.query.query) return error({}, \"No text query provided\");\n    if (!req.query.number) return error({}, \"No phone number provided\");\n\n    const io = req.app.get('socketio');\n\n    var overrideMessage;\n\n    Recipient.findOneWithDeleted({ number: req.query.number })\n\n    .then(function(recipient) {\n\n        var promises = {};\n\n        if (recipient) {\n\n            if (recipient.deleted) {\n                recipient.restore();\n                overrideMessage = \"Welcome back!\";\n            }\n\n            const incoming = new Message({\n                text: req.query.query,\n                number: req.query.number,\n                type: 'incoming'\n            });\n\n            promises.recipient = recipient;\n            promises.message = incoming.save();\n            promises.catFact = Fact.getFact();\n            promises.catbotResponse = catbot.textRequest(req.query.query, {\n                sessionId: req.query.number\n            });\n        } else {\n\n            var newRecipient = new Recipient({\n                name: req.query.name,\n                number: req.query.number.replace(/\\D/g, '').replace(/^1+/, '')\n            });\n\n            promises.recipient = newRecipient.save();\n\n        }\n\n        return Promise.props(promises);\n    })\n\n    .then(result => {\n\n        var response;\n\n        if (result.message) {\n            if (result.catbotResponse.result && result.catbotResponse.result.fulfillment.speech) {\n                response = result.catbotResponse.result.fulfillment.speech;\n            } else {\n                response = result.catFact.text;\n            }\n        } else {\n            response = strings.welcomeMessage();\n        }\n\n        const outgoing = new Message({ text: overrideMessage || response, number: req.query.number, type: 'outgoing' });\n\n        outgoing.save().then(message => {\n            io.emit('message', { message: message, recipient: result.recipient });\n\n            return success(message);\n        });\n    })\n\n    .catch(err => {\n        return error(err.message || null);\n    });\n\n    function success(message) {\n        res.status(200).json({\n            response: message,\n            delay: computeTypingDelay(message.text),\n            number: req.query.number\n        });\n    }\n\n    function error(error, message) {\n        error.message = message;\n        res.status(400).json(error);\n    }\n\n    function computeTypingDelay(string) {\n        let delay = 0;\n        delay += (string.length / 2);\n        delay += Math.round(Math.random() * 10) * (Math.random() < 0.05 ? -1 : 1);\n        return Math.abs(delay) + 2;\n    }\n});\n\nmodule.exports = router;", "app/routes/console.routes.js": "const express = require('express');\nconst router = express.Router();\nconst Promise = require('bluebird');\n\nconst { isAuthenticated, isAdmin } = require('../middleware');\n\nconst Recipient = require.main.require('./app/models/recipient');\nconst UnsubscribeDate = require.main.require('./app/models/unsubscribe-date');\nconst User = require.main.require('./app/models/user');\nconst Fact = require.main.require('./app/models/fact');\n\nrouter.get('/data', isAuthenticated, isAdmin, async (req, res) => {\n    \n    const {recipients, totalRecipients, unsubscribeDates, users, overrideFacts} = await Promise.props({\n        recipients:         Recipient.find().sort('-createdAt').limit(15).populate({path: 'addedBy', select: 'name'}),\n        totalRecipients:    Recipient.count(),\n        unsubscribeDates:   UnsubscribeDate.find().sort('-createdAt').limit(15),\n        users:              User.find().sort('-createdAt').limit(15),\n        overrideFacts:      Fact.find({sendDate: {$exists: true}}).limit(15)\n    });\n    \n    const response = {\n        recipients: {\n            all: recipients,\n            total: totalRecipients\n        },\n        unsubscribeDates,\n        users,\n        overrideFacts\n    };\n    \n    return res.status(200).json(response);\n});\n\nmodule.exports = router;", "app/routes/contact.routes.js": "const express = require('express');\nconst router = express.Router();\nconst { google } = require('googleapis');\nconst googleConfig = require.main.require('./app/config/google');\nconst googleContacts = google.people('v1');\n\nconst { isAuthenticated } = require('../middleware');\n\nconst User = require.main.require('./app/models/user');\nconst Recipient = require.main.require('./app/models/recipient');\n\nrouter.get('/', isAuthenticated, (req, res) => {\n\t\n\tconst oauth2Client = googleConfig.newOauth2Client({\n\t\taccessToken: User.decryptAccessToken(req.user.google.accessToken),\n\t\trefreshToken: req.user.google.refreshToken\n\t});\n    const animalType = req.query.animal_type;\n\t\n    googleContacts.people.connections.list({\n        auth: oauth2Client,\n        resourceName: 'people/me',\n        pageSize: 500,\n        'requestMask.includeField': ['person.phoneNumbers', 'person.names'],\n        sortOrder: 'LAST_MODIFIED_ASCENDING'\n    }, (err, data) => {\n        if (err) return res.status(err.code || 400).json(err);\n        \n        /*\n         * Reduce Google Contacts result to simple array of {name: '', number: ''}'s\n         * First filter out objects without any phone numbers,\n         * then rip phone numbers out of their contact's object and make new objects for each one\n         */\n        if (data.connections) {\n            let contacts = data.connections\n            \t.filter(o => o.phoneNumbers && o.phoneNumbers.length > 0)\n            \t.map((o, i) => {\n    \t        \tif (!o.phoneNumbers) return o;\n    \t        \tvar contacts = [];\n    \t        \tfor (var i = 0; i < o.phoneNumbers.length; i++) {\n    \t\t            contacts.push({\n    \t\t                name: o.names ? (o.names[0].givenName + (o.names[0].familyName ? (' ' + o.names[0].familyName) : '')) : undefined,\n    \t\t                number: o.phoneNumbers[i].value.replace(/\\D/g,'').replace(/^1+/, '')\n    \t            \t});\n    \t        \t}\n    \t        \treturn contacts;\n    \t        });\n            \n            // Flatten array and reverse sort order\n            contacts = [].concat.apply([], contacts).reverse();\n            \n            Recipient.find({number: {$in: contacts.map(o => o.number)}}).then(function(recipients) {\n                contacts = contacts.map(contact => {\n                    contact.added = !!recipients.find(recipient => {\n                        return recipient.number == contact.number && recipient.subscriptions.includes(animalType);\n                    });\n                    return contact;\n                });\n                \n                return res.status(200).json(contacts); \n            });\n        } else {\n            return res.status(204).json([]);\n        }\n    });\n});\n\nmodule.exports = router;", "app/routes/fact.routes.js": "const express = require('express');\nconst router = express.Router();\n\nconst strings = require.main.require('./app/config/strings.js');\nconst { isAuthenticated, logApiRequest } = require('../middleware');\n\nconst Fact = require.main.require('./app/models/fact');\nconst User = require.main.require('./app/models/user');\n\nrouter.get('/', async(req, res) => {\n    try {\n        const facts = await Fact.find().limit(5);\n        return res.status(200).json(facts);\n    } catch (err) {\n        return res.status(err.status || 400).json(err);\n    }\n})\n\n// Get submitted facts\nrouter.get('/me', async(req, res) => {\n\n    const animalType = req.query.animal_type ? req.query.animal_type.split(',') : ['cat'];\n\n    try {\n        const data = await Fact.find({\n                user: req.user._id,\n                type: { $in: animalType }\n            })\n            .select('text type')\n            .populate('user', 'name')\n            .limit(10)\n\n        return res.status(200).json(data);\n    } catch (err) {\n        return res.status(400).json(err);\n    }\n});\n\n// Get a random fact\nrouter.get('/random', logApiRequest, async(req, res) => {\n\n    const animalType = req.query.animal_type ? req.query.animal_type.split(',') : ['cat'];\n    const amount = req.query.amount;\n\n    if (amount > 500) {\n        return res.status(405).json({ message: 'Limited to 500 facts at a time' });\n    }\n\n    try {\n        const facts = await Fact.getFact({ amount, animalType });\n        return res.status(200).json(facts);\n    } catch (err) {\n        return res.status(err.status).json(err);\n    }\n});\n\n// Get fact by ID\nrouter.get('/:factID', logApiRequest, async(req, res) => {\n    try {\n        const fact = await Fact.findById(req.params.factID).populate('user', 'name photo');\n\n        if (!fact) {\n            return res.status(404).json({ message: 'Fact not found' });\n        }\n\n        return res.status(200).json(fact);\n    } catch (err) {\n        return res.status(400).json(err);\n    }\n});\n\n// Submit a fact\nrouter.post('/', isAuthenticated, async(req, res) => {\n\n    if (!req.body.factText) {\n        return res.status(400).json({ message: \"Missing body paramter: factText\" });\n    }\n    if (!req.body.animalType) {\n        return res.status(400).json({ message: \"Missing body parameter: animalType\" });\n    }\n\n    const io = req.app.get('socketio');\n\n    let text = req.body.factText;\n\n    text = text.charAt(0).toUpperCase() + text.slice(1); // Capitalize\n    text += text[text.length - 1] == \".\" ? \"\" : \".\"; // Add period to end\n\n    const fact = new Fact({\n        user: req.user._id,\n        text,\n        type: req.body.animalType\n    });\n\n    try {\n        const savedFact = await fact.save();\n\n        const populatedFact = await User.populate(savedFact, { path: 'user', select: 'name' });\n\n        io.emit('fact', populatedFact);\n\n        return res.status(200).json(populatedFact);\n    } catch (err) {\n        if (err.code === 11000) {\n            err.message = strings.fact.exists;\n            return res.status(409).json(err);\n        }\n        return res.status(400).json(err);\n    }\n});\n\nmodule.exports = router;", "app/routes/index.js": "var router = require('express').Router();\n\n// Import all route groups\nrouter.use('/auth', require('./auth.routes'));\nrouter.use('/users', require('./user.routes'));\nrouter.use('/catbot', require('./catbot.routes'));\nrouter.use('/recipients', require('./recipient.routes'));\nrouter.use('/facts', require('./fact.routes'));\nrouter.use('/console', require('./console.routes'));\nrouter.use('/contacts', require('./contact.routes'));\nrouter.use('/webhook', require('./webhook.routes'));\n\nmodule.exports = router;", "app/routes/recipient.routes.js": "const express = require('express');\nconst router = express.Router();\n\nconst { isAuthenticated, isAdmin } = require('../middleware');\nconst strings = require.main.require('./app/config/strings.js');\nconst IFTTTService = require.main.require('./app/services/ifttt.service.js');\n\nconst Recipient = require.main.require('./app/models/recipient');\nconst Message = require.main.require('./app/models/message');\nconst VerificationCode = require.main.require('./app/models/verification-code');\n\n\n// Get all recipients\nrouter.get('/', isAuthenticated, isAdmin, async(req, res) => {\n\n    try {\n        const animalType = req.query.animal_type ? { $in: req.query.animal_type.split(',') } : { $exists: true };\n\n        const recipients = await Recipient.find({\n                subscriptions: animalType\n            })\n            .sort('-createdAt')\n            .populate({\n                path: 'addedBy',\n                select: 'name'\n            });\n\n        return res.status(200).json(recipients);\n    } catch (err) {\n        return res.status(400).json(err);\n    }\n});\n\n// Get user's recipients\nrouter.get('/me', isAuthenticated, async(req, res) => {\n\n    const animalType = req.query.animal_type ? req.query.animal_type.split(',') : undefined;\n\n    try {\n        const recipients = await Recipient.findWithDeleted({\n            addedBy: req.user._id,\n            subscriptions: {\n                $in: animalType\n            }\n        }).sort('name');\n\n        console.log(recipients);\n\n        return res.status(200).json(recipients);\n    } catch (err) {\n        console.error(err);\n        return res.status(400).json(err);\n    }\n});\n\n// Add new recipient(s)\nrouter.post('/', isAuthenticated, async(req, res) => {\n\n    // TODO: Sanitize phone number input on server side\n\n    const requestedRecipients = req.body.recipients || [req.body.recipient];\n    const animalTypes = req.body.animalTypes;\n\n    /* \n     * requestedRecipients: [{\n     *     name: String,\n     *     number: String\n     * }],\n     * animalTypes: [String<Animal>]\n     */\n\n    if (!requestedRecipients.length) {\n        return res.status(400).json({ message: `No recipients provided` });\n    }\n\n    // If recipient already exists but is 'deleted', restore recipient to\n    // the new user account\n    const existingRecipients = await Recipient.findDeleted({\n        number: {\n            $in: requestedRecipients.map(r => r.number)\n        }\n    });\n\n    if (existingRecipients.length) {\n        existingRecipients.forEach(r => r.remove());\n    }\n\n    try {\n        const results = await Recipient.addRecipients({\n            authenticatedUser: req.user,\n            requestedRecipients,\n            requestedSubscriptions: animalTypes\n        });\n\n        return res.status(200).json(results);\n    } catch (err) {\n        return res.status(err.status || 400).json(err);\n    }\n});\n\n// Restore recipient with new subscriptions\nrouter.patch('/:recipientId/restore', isAuthenticated, async(req, res) => {\n\n    const recipientId = req.params.recipientId;\n    const resubscriptions = req.body.resubscriptions;\n\n    console.log(recipientId, resubscriptions);\n\n    try {\n        await Recipient.restore({ _id: recipientId });\n\n        const recipient = await Recipient.findOneAndUpdate({ _id: recipientId }, {\n            $set: {\n                subscriptions: resubscriptions\n            }\n        }, {\n            new: true\n        });\n        console.log(recipient);\n\n        return res.status(200).json(recipient);\n    } catch (err) {\n        return res.status(err.status || 400).json(err);\n    }\n});\n\nrouter.patch('/:recipientId', isAuthenticated, async(req, res) => {\n\n    // TODO: only allow to edit recipient if user isAdmin or is addedBy them\n\n    try {\n        const recipient = await Recipient.update({ _id: req.params.recipientId }, {\n            $set: {\n                name: req.body.name,\n                number: req.body.number\n            }\n        });\n\n        return res.status(200).json(recipient);\n    } catch (err) {\n        return res.status(err.statusCode || 400).json(err);\n    }\n});\n\n// Unsubscribe\nrouter.delete('/me', isAuthenticated, async(req, res) => {\n\n    if (!req.query.verificationCode) {\n        return res.status(403).json({\n            message: strings.noVerificationCode\n        });\n    }\n\n    const submittedCode = req.query.verificationCode.trim();\n    const verificationCode = await VerificationCode.findOne({ code: submittedCode });\n    const number = verificationCode ? verificationCode.data : undefined;\n\n    if (!verificationCode || !verificationCode.user.equals(req.user._id)) {\n        return res.status(403).json({\n            message: strings.invalidVerificationCode\n        });\n    }\n\n    await Recipient.delete({ number });\n    await VerificationCode.findByIdAndRemove(verificationCode._id);\n\n    const formattedPhone = `(${number.substr(0,3)}) ${number.substr(3,3)}-${number.substr(6,4)}`;\n\n    return res.status(200).json({\n        message: `Successfully unsubscribed ${formattedPhone}`\n    });\n});\n\n// Remove one or more recipients\nrouter.delete('/', isAuthenticated, async(req, res) => {\n\n    const query = { _id: { $in: req.query.recipients } };\n\n    const action = req.query.soft == 'false' ? 'remove' : 'delete';\n\n    if (!req.user.isAdmin && action == 'remove') {\n        return res.status(403).json({ message: strings.unauthorized });\n    }\n\n    // TODO: only allow to delete recipient if user is addedBy them\n\n    try {\n        const data = await Recipient[action](query);\n        return res.status(200).json(data);\n    } catch (err) {\n        return res.status(400).json(err);\n    }\n});\n\n// Get a recipient's catversation\nrouter.get('/:number/conversation', isAuthenticated, async(req, res) => {\n\n    try {\n        const results = await Promise.all([\n            Recipient.findOne({ addedBy: req.user._id, number: req.params.number }),\n            Message.find({ number: req.params.number })\n        ]);\n\n        if (results[0]) {\n            return res.status(200).json(results[1]);\n        } else {\n            return res.status(403).json({ message: \"You aren't facting this person\" });\n        }\n    } catch (err) {\n        return res.status(400).json(err);\n    }\n});\n\nmodule.exports = router;", "app/routes/user.routes.js": "const express = require('express');\nconst router = express.Router();\n\nconst IFTTTService = require.main.require('./app/services/ifttt.service.js');\nconst { isAuthenticated } = require('../middleware');\n\nconst User = require.main.require('./app/models/user');\nconst VerificationCode = require.main.require('./app/models/verification-code');\nconst strings = require.main.require('./app/config/strings.js');\n\nrouter.get('/me', isAuthenticated, (req, res) => {\n\treturn res.status(200).json(req.user);\n});\n\nrouter.delete('/me', isAuthenticated, async (req, res) => {\n    // Confirm intention to delete by checking inputted email\n    \n    if (req.user.email !== req.query.verificationEmail)\n        return res.status(403).json({message: 'Email addresses do not match'});\n    \n    \n    try {\n        await User.delete({_id: req.user._id});\n        return res.status(200).json({message: 'Account deleted'});\n    }\n    catch (err) {\n        return res.status(200).json({message: err.message || 'Failed to delete account', err});\n    }\n        \n});\n\nrouter.post('/me/profile/phone/verification-code', isAuthenticated, async (req, res) => {\n\n    const inputData = {\n        user: req.user._id,\n        type: 'phone',\n        data: req.body.phone\n    };\n    const verificationCode = new VerificationCode(inputData);\n    \n    try {\n        const result = await verificationCode.save();\n        \n    \tIFTTTService.sendSingleMessage({\n    \t    number: req.body.phone,\n    \t    message: `${result.code} is your Cat Facts verification code.`\n    \t});\n        \n        return res.status(200).json({\n            message: \"Created verification code\",\n            ...inputData\n        });\n    } catch (err) {\n        console.error(err);\n        return res.status(400).json(err);\n    }\n});\n\nrouter.put('/me/profile/phone', isAuthenticated, async (req, res) => {\n    \n    if (!req.body.verificationCode) {\n        return res.status(403).json({\n            message: strings.noVerificationCode\n        });\n    }\n    \n    const submittedCode = req.body.verificationCode.trim();\n    const verificationCode = await VerificationCode.findOne({code: submittedCode});\n    \n    if (!verificationCode || verificationCode.user != req.user._id) {\n        return res.status(403).json({\n            message: strings.invalidVerificationCode\n        });\n    }\n    \n    const updatedUser = await User.findByIdAndUpdate(req.user._id, {$set: {\n        phone: verificationCode.data\n    }}, {\n        new: true\n    });\n    \n    await VerificationCode.findByIdAndRemove(verificationCode._id);\n    \n    return res.status(200).json(updatedUser);\n});\n\nmodule.exports = router;\n\n\n// https://stackoverflow.com/questions/17200122/prepending-namespace-to-all-of-a-json-objects-keys\nfunction prefixObjectKeys(obj, prefix){\n\n    if (typeof obj !== 'object' || !obj){\n        return false;\n    }\n\n    var keys = Object.keys(obj),\n        keysLen = keys.length;\n        prefix = prefix || '';\n\n    for (var i=0; i<keysLen; i++){\n\n        obj[prefix + keys[i]] = obj[keys[i]];\n        if (typeof obj[keys[i]] === 'object'){\n            prefixObjectKeys(obj[prefix + keys[i]], prefix);\n        }\n        delete obj[keys[i]];\n    }\n\n    return obj;\n}", "app/routes/webhook.routes.js": "const express = require('express');\nconst router = express.Router();\nconst Promise = require('bluebird');\n\nconst UnsubscribeDate = require('../models/unsubscribe-date');\nconst Recipient = require('../models/recipient');\nconst Fact = require('../models/fact');\nconst strings = require('../config/strings');\n\n\nconst keys = require('../config/keys');\nconst apiai = require('apiai-promise');\nconst catbot = apiai(keys.apiai.accessToken);\nconst crypto = require('crypto');\n\nconst processWebhook = req => {\n    return new Promise(async (resolve, reject) => {\n    \n        if (!req.body || !req.body.result) {\n        \treject(new Error('No request body provided'));\n        }\n        \n    \tswitch (req.body.result.action) {\n    \t    case 'fact.get':\n    \t        \n                const fact = await Fact.getFact();\n                resolve({message: fact.text});\n            \n            break;\n            \n            case 'recipient.add':\n                if (!req.body.result.parameters) reject();\n                \n                // Extract params from Dialogflow\n                const parameters = req.body.result.parameters,\n                      name = parameters['given-name'] + (parameters['last-name'] ? ' ' + parameters['last-name'] : ''),\n                      number = parameters['phone-number'].replace(/\\D/g,'').replace(/^1+/, ''),\n                      requestedSubscriptions = parameters['animals'];\n                    \n                const message = Recipient.addRecipients({\n                    requestedRecipients: [{\n                        name,\n                        number\n                    }],\n                    requestedSubscriptions\n                });\n                \n                resolve({message});\n            break;\n            \n            case 'recipient.unsubscribe':\n                const canUnsubscribe = await UnsubscribeDate.allowUnsubscribe();\n                \n                if (canUnsubscribe) {\n                    const recipientNumber = req.body.sessionId;\n                    \n                    try {\n                        await Recipient.delete({number: recipientNumber});\n                        resolve({message: req.body.result.fulfillment.messages[0].speech});\n                    }\n                    \n                    catch (err) {\n                        reject(err);\n                    }\n                } else {\n                    // Get unsubscribe message from CatBot\n                    const randomSessionId = crypto.createHash('md5').update((new Date()).getTime().toString()).digest('hex');\n                    \n                    const response = await catbot.textRequest('unsubscribe', {sessionId: randomSessionId});\n                    \n                    resolve({message: response.result.fulfillment.speech});\n                }\n            break;\n                \n            default:\n                reject(new Error('No action specified'));\n            break;\n    \t}\n    });\n};\n\n\n// Route for api.ai webhook\nrouter.post('/', async (req, res) => {\n    \n    try {\n        const response = await processWebhook(req);\n        \n        return res.json({\n        \tspeech: response.message,\n        \tdisplayText: response.message,\n        \tdata: {},\n        \tcontextOut: [],\n        \tsource: \"Cat Facts\"\n        });\n    }\n    \n    catch (err) {\n        var message = err.message || err.errors[Object.keys(err.errors)[0]].message || strings.error;\n        return res.json({displayText: message, speech: message, data: err});\n    }\n\t\n});\n\nmodule.exports = router;"}}